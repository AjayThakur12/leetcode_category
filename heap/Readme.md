Heap
===

Top-K algorithm
---

While iterating through the input array, a heap maintains the current largest K elements. 
When a new element is larger the smallest of the current top-K, insert new element into the heap, then pop up the smallest element in the heap.

**LC215  Kth Largest Element in an Array**
```
from heapq import heapreplace, heappush
class Solution:
    def findKthLargest(self, nums, k):
        h = []
        for n in nums:
            if len(h)<k:
                heappush(h,n)
            elif n>h[0]:
                heapreplace(h,n)
        return h[0]
```

The heapq is a min-heap (smallest element at `h[0]`). `heapreplace(heap, item)` pop and return the smallest item, and also push the new item. The heap size doesnâ€™t change.

**LC 313 Super Ugly Number**
Write a program to find the n-th super ugly number.
Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k.

For each prime `p_i`, `x*p_i` has the same order as the `x`s'. We do not need to compare `x*p_i`, instead, we just increase the current `x` to the next ugly number (least larger than the current `x`). In that way, `x*p_i` is naturally generated by ascending order.

Therefore, we maintain an index `idx_i` for each prime `p_i`, pointing to the `idx_i`-th ugly number `ug[idx_i]`.

Given all primes, the next ugly number is `min(ug[idx_i] * p_i for all i)`. 

Insert this next ugly number into the list `ug`; Replace it by `ug[idx_i + 1] * p_i` in the heap and `idx_i++`.

```
from heapq import heappush,heappop,heapify
class Solution:
    def nthSuperUglyNumber(self, n: int, primes: List[int]) -> int:
        ug = [1]
        idx = {p:0 for p in primes}
        hp = [(p * ug[idx[p]], p) for p in primes]
        heapify(hp)
        while len(ug) < n:
            nxt_val = hp[0][0]
            ug.append(nxt_val)
            while hp and nxt_val == hp[0][0]:
                val, p = heappop(hp)
                idx[p] += 1
                heappush(hp, (p * ug[idx[p]], p) )
        return ug[-1]
```

P.S. Define custom comparator for Python heap
---
```
@functools.total_ordering
class Element:
    def __init__(self, word, n):
        self.word = word
        self.n = n
    
    def __lt__(self, other):
        if self.n == other.n:
            return self.word > other.word
        return self.n < other.n
    
    def __eq__(self, other):
        return self.n==other.n and self.word==other.word
```
and `heapq.heappush(hp, Element(word, n))` would do the job.
